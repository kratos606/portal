import * as THREE from "three"
import CANNON from "cannon"
import Game from "./game"
import { thickness } from "three/examples/jsm/nodes/core/PropertyNode.js";

class Portal {
    constructor(scene, renderer) {
        this.scene = scene;
        this.renderer = renderer;
        this.tmpScene = new THREE.Scene();

        this.rotationYMatrix = new THREE.Matrix4().makeRotationY(Math.PI);
        this.inverse = new THREE.Matrix4();
        this.dstInverse = new THREE.Matrix4();
        this.srcToCam = new THREE.Matrix4();
        this.srcToDst = new THREE.Matrix4();
        this.result = new THREE.Matrix4();

        this.dstRotationMatrix = new THREE.Matrix4();
        this.normal = new THREE.Vector3();
        this.clipPlane = new THREE.Plane();
        this.clipVector = new THREE.Vector4();
        this.q = new THREE.Vector4();
        this.projectionMatrix = new THREE.Matrix4();
        this.cameraInverseViewMat = new THREE.Matrix4();

        this.originalCameraMatrixWorld = new THREE.Matrix4();
        this.originalCameraProjectionMatrix = new THREE.Matrix4();

        this.maxRecursion = 2;
    }

    computePortalProjectionMatrix(sourcePortal, viewMat, projMat){
        const destinationPortal = sourcePortal.pair;
        this.cameraInverseViewMat.copy(viewMat).invert();
        this.dstRotationMatrix.identity().extractRotation(destinationPortal.matrixWorld);
  
        // TODO: Use -1 if dot product is negative (?)
        this.normal.set(0, 0, 1).applyMatrix4(this.dstRotationMatrix);
  
        this.clipPlane.setFromNormalAndCoplanarPoint(this.normal, destinationPortal.position);
        this.clipPlane.applyMatrix4(this.cameraInverseViewMat);
  
        this.clipVector.set(
           this.clipPlane.normal.x,
           this.clipPlane.normal.y,
           this.clipPlane.normal.z,
           this.clipPlane.constant,
        );
        this.projectionMatrix.copy(projMat);
  
        this.q.x = (Math.sign(this.clipVector.x) + this.projectionMatrix.elements[8]) / this.projectionMatrix.elements[0];
        this.q.y = (Math.sign(this.clipVector.y) + this.projectionMatrix.elements[9]) / this.projectionMatrix.elements[5];
        this.q.z = -1.0;
        this.q.w = (1.0 + this.projectionMatrix.elements[10]) / projMat.elements[14];
  
        this.clipVector.multiplyScalar(2 / this.clipVector.dot(this.q));
  
        this.projectionMatrix.elements[2] = this.clipVector.x;
        this.projectionMatrix.elements[6] = this.clipVector.y;
        this.projectionMatrix.elements[10] = this.clipVector.z + 1.0;
        this.projectionMatrix.elements[14] = this.clipVector.w;
  
        return this.projectionMatrix;
     }

    computePortalViewMatrix(sourcePortal, viewMat){
        this.srcToCam.multiplyMatrices(this.inverse.copy(viewMat).invert(), sourcePortal.matrixWorld.clone());
        this.dstInverse.copy(sourcePortal.pair.matrixWorld.clone()).invert();
        this.srcToDst.identity().multiply(this.srcToCam).multiply(this.rotationYMatrix).multiply(this.dstInverse);
        this.result.copy(this.srcToDst).invert();
        return this.result;
    }

    renderScene(camera, children, viewMat, projMat){
        this.tmpScene.children = children;
        this.originalCameraMatrixWorld.copy(camera.matrixWorld);
        this.originalCameraProjectionMatrix.copy(camera.projectionMatrix);
        const position = new THREE.Vector3();
        const rotation = new THREE.Quaternion();
        const scale = new THREE.Vector3();
        viewMat.decompose(position, rotation, scale);
        camera.position.copy(position);
        camera.quaternion.copy(rotation);
        camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
        camera.projectionMatrix.copy(projMat);
        camera.updateMatrixWorld(true);
        this.renderer.render(this.tmpScene, camera);
        camera.matrixAutoUpdate = true;
        camera.matrixWorld.copy(this.originalCameraMatrixWorld);
        camera.matrixWorldInverse.copy(this.originalCameraMatrixWorld).invert();
        camera.projectionMatrix.copy(this.originalCameraProjectionMatrix);
    }

    render(camera, recursionLevel = 0, virtualCamera, portals,viewMat,projMat) {
        if (recursionLevel > this.maxRecursion) return;

        const gl = this.renderer.getContext();

        for (let i = 0; i < portals.length; i++) {
            let portal = portals[i];

            gl.colorMask(false, false, false, false);
            gl.depthMask(false);
            gl.disable(gl.DEPTH_TEST);
            gl.enable(gl.STENCIL_TEST);
            gl.stencilFunc(gl.NOTEQUAL, recursionLevel, 0xff);
            gl.stencilOp(gl.INCR, gl.KEEP, gl.KEEP);
            gl.stencilMask(0xff);

            this.renderScene(camera, [portal, camera],viewMat,projMat);

            const destViewMat = this.computePortalViewMatrix(portal, viewMat).clone();
            const destProjMat = this.computePortalProjectionMatrix(portal, destViewMat, projMat).clone();

            if (recursionLevel === this.maxRecursion) {
                gl.colorMask(true, true, true, true);
                gl.depthMask(true);
                this.renderer.clear(false, true, false);
                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.STENCIL_TEST);
                gl.stencilMask(0x00);
                gl.stencilFunc(gl.EQUAL, recursionLevel + 1, 0xff);
                this.renderScene(virtualCamera, this.scene.children.filter((child) => child!==portal),destViewMat,destProjMat);
            } else {
                this.render(virtualCamera, recursionLevel + 1, virtualCamera, [portal, portal.pair],destViewMat,destProjMat);
            }

            gl.colorMask(false, false, false, false);
            gl.depthMask(false);
            gl.enable(gl.STENCIL_TEST);
            gl.stencilMask(0xff);
            gl.stencilFunc(gl.NOTEQUAL, recursionLevel + 1, 0xFF);
            gl.stencilOp(gl.DECR, gl.KEEP, gl.KEEP);

            this.renderScene(camera, [portal, camera],viewMat,projMat);
        }

        gl.disable(gl.STENCIL_TEST);
        gl.stencilMask(0x00);
        gl.colorMask(false, false, false, false);
        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        gl.depthFunc(gl.ALWAYS);
        this.renderer.clear(false, true, false);

        this.renderScene(camera, [...portals, camera],viewMat,projMat);

        gl.depthFunc(gl.LESS);
        gl.enable(gl.STENCIL_TEST);
        gl.stencilMask(0x00);
        gl.stencilFunc(gl.LEQUAL, recursionLevel, 0xff);
        gl.colorMask(true, true, true, true);
        gl.depthMask(true);
        gl.enable(gl.DEPTH_TEST);

        if(recursionLevel == 0){
            this.renderScene(camera, this.scene.children.filter((child)=>child.class!=='player'),viewMat,projMat);
        }
        else{
            this.renderScene(camera, this.scene.children,viewMat,projMat);
        }
    }
}

export default class World {
    constructor() {
        this.game = new Game()
        this.scene = this.game.scene
        this.physics = new CANNON.World();
        this.physics.quatNormalizeSkip = 0
        this.physics.quatNormalizeFast = false
        this.solver = new CANNON.GSSolver();
        this.physics.defaultContactMaterial.contactEquationStiffness = 1e9;
        this.physics.defaultContactMaterial.contactEquationRelaxation = 1;
        this.physics.defaultMaterial.friction = 1
        this.physics.defaultMaterial.restitution = 0
        this.solver.iterations = 10;
        this.solver.tolerance = 0.1;
        this.physics.solver = new CANNON.SplitSolver(this.solver);
        this.physics.gravity.set(0,-50,0);
        this.physics.broadphase = new CANNON.NaiveBroadphase();
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.leftPortal = []
        this.rightPortal = []
        this.virtualCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        this.scene.add(this.virtualCamera);
        this.portalHandler = new Portal(this.scene, this.game.renderer.instance);
        this.active = ''
        window.addEventListener('click', this.shoot.bind(this));
        this.setWorld()
        this.loadTextures()

    }

    worldToLocal(object, vector) {
        const worldInverse = new THREE.Matrix4().copy(object.matrixWorld).invert();
        return vector.clone().applyMatrix4(worldInverse);
    }
    
    localToWorld(object, vector) {
        return vector.clone().applyMatrix4(object.matrixWorld);
    }

    shoot(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera({x:0,y:0}, this.game.camera.instance);

        const intersects = this.raycaster.intersectObjects([
            this.plane, this.roof, this.scene.getObjectByName('backWall'),
            this.scene.getObjectByName('frontWall'), this.scene.getObjectByName('leftWall'),
            this.scene.getObjectByName('rightWall')
        ]);

        if (intersects.length > 0) {
            const intersection = intersects[0];
            const object = intersection.object;

            const geometry = new THREE.CircleGeometry(5, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const circle = new THREE.Mesh(geometry, material);

            const portalSize = new THREE.Vector2(10, 15);
            const halfPortalSize = portalSize.clone().multiplyScalar(0.5);
            const wallSize = new THREE.Vector2(object.geometry.parameters.width, object.geometry.parameters.height);
            const halfWallSize = wallSize.clone().multiplyScalar(0.5);

            let localPosition = this.worldToLocal(object, intersection.point);

            // Clamp the local position to the nearest valid point within the wall bounds
            localPosition.x = THREE.MathUtils.clamp(localPosition.x, -halfWallSize.x + halfPortalSize.x, halfWallSize.x - halfPortalSize.x);
            localPosition.y = THREE.MathUtils.clamp(localPosition.y, -halfWallSize.y + halfPortalSize.y, halfWallSize.y - halfPortalSize.y);

            // Convert back to world coordinates
            const validPoint = this.localToWorld(object, localPosition);

            circle.position.copy(validPoint);
            circle.rotation.copy(object.rotation);
            circle.scale.y = 1.5;

            // Adjust circle position slightly to ensure it's on the wall
            circle.position.addScaledVector(circle.getWorldDirection(new THREE.Vector3()), 0.01);
            this.boxBody = new CANNON.Body()
            this.boxBody.mass = 0
            this.boxBody.material = this.defaultMaterial
            // this.boxBody.collisionFilterGroup = 1
            // this.boxBody.collisionFilterMask = 0
            this.boxBody.collisionResponse = false
            this.boxBody.addShape(new CANNON.Box(new CANNON.Vec3(2.5,3.75,2.5)))
            this.boxBody.quaternion.copy(circle.quaternion)
            this.boxBody.position.copy(circle.position)
            this.boxBody.class = 'portal'
            this.boxBody.object = intersects[0].object
            this.physics.addBody(this.boxBody)
            circle.physicObject = this.boxBody

            const geometry1 = new THREE.PlaneGeometry(19, 19);
            let materialPortal;

            if (event.button === 0) {
                this.materialBlue = new THREE.ShaderMaterial({
                    uniforms: {
                        iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        iTime: { value: 0 }
                    },
                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShaderOrange').textContent
                });
                materialPortal = this.materialBlue;
                this.leftPortal.push(circle);
            } else if (event.button === 2) {
                this.materialOrange = new THREE.ShaderMaterial({
                    uniforms: {
                        iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        iTime: { value: 0 }
                    },
                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShaderBlue').textContent
                });
                materialPortal = this.materialOrange;
                this.rightPortal.push(circle);
            }

            const planePortal = new THREE.Mesh(geometry1, materialPortal);
            planePortal.position.copy(circle.position);
            planePortal.rotation.copy(circle.rotation);
            planePortal.position.addScaledVector(circle.getWorldDirection(new THREE.Vector3()), 0.01);

            this.scene.add(planePortal);
            circle.torus = planePortal;
        }
    }

    calculateAngle(v1, v2) {
        const dot = v1.dot(v2);
        const angle = Math.acos(dot / (v1.length() * v2.length()));
        return angle;
    }

    setWorld() {
        const wallShape = new CANNON.Box(new CANNON.Vec3(60, 30, 1))
        this.plane = new THREE.Mesh(
            new THREE.PlaneGeometry(60, 60),
            new THREE.MeshStandardMaterial({
                roughness: 0.2,
                metalness: 0.1
            })
        )
        this.plane.rotation.x = -Math.PI / 2
        this.plane.receiveShadow = true
        this.scene.add(this.plane)

        const floorShape = new CANNON.Plane()
        const floorBody = new CANNON.Body()
        floorBody.mass = 0
        floorBody.addShape(floorShape)
        floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(- 1, 0, 0), Math.PI * 0.5)
        this.physics.addBody(floorBody)

        this.plane.physicObject = floorBody

        let backWallMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(60, 30),
            new THREE.MeshStandardMaterial({
                color: 0xf0ffff,
                side: THREE.DoubleSide
            })
        )
        backWallMesh.position.z = 30
        backWallMesh.position.y = 15
        backWallMesh.rotation.y = Math.PI
        this.scene.add(backWallMesh)

        const backWallBody = new CANNON.Body()
        backWallBody.mass = 0
        backWallBody.material = this.defaultMaterial
        backWallBody.addShape(wallShape)
        backWallBody.quaternion.copy(backWallMesh.quaternion)
        backWallBody.position.copy(backWallMesh.position)
        this.physics.addBody(backWallBody)

        backWallMesh.physicObject = backWallBody

        const frontWallBody = new CANNON.Body()
        frontWallBody.mass = 0
        frontWallBody.addShape(wallShape)
        frontWallBody.quaternion.copy(backWallMesh.quaternion)
        frontWallBody.position.set(0, 15, -30)
        this.physics.addBody(frontWallBody)

        let frontWallMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(60, 30),
            new THREE.MeshStandardMaterial({
                color: 0xff0fff,
                side: THREE.DoubleSide
            })
        )
        frontWallMesh.position.z = -30
        frontWallMesh.position.y = 15
        frontWallMesh.physicObject = frontWallBody
        this.scene.add(frontWallMesh)

        let leftWallMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(60, 30),
            new THREE.MeshStandardMaterial({
                color: 0xfff0ff,
                side: THREE.DoubleSide
            })
        )
        leftWallMesh.rotation.y = Math.PI / 2
        leftWallMesh.position.x = -30
        leftWallMesh.position.y = 15
        this.scene.add(leftWallMesh)

        const leftWallBody = new CANNON.Body()
        leftWallBody.mass = 0
        leftWallBody.addShape(wallShape)
        leftWallBody.quaternion.copy(leftWallMesh.quaternion)
        leftWallBody.position.copy(leftWallMesh.position)
        this.physics.addBody(leftWallBody)

        leftWallMesh.physicObject = leftWallBody


        let rightWallMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(60, 30),
            new THREE.MeshStandardMaterial({
                color: 0xffff0f,
                side: THREE.DoubleSide
            })
        )
        rightWallMesh.rotation.y = -Math.PI / 2
        rightWallMesh.position.x = 30
        rightWallMesh.position.y = 15
        this.scene.add(rightWallMesh)

        const rightWallBody = new CANNON.Body()
        rightWallBody.mass = 0
        rightWallBody.addShape(wallShape)
        rightWallBody.quaternion.copy(rightWallMesh.quaternion)
        rightWallBody.position.copy(rightWallMesh.position)
        this.physics.addBody(rightWallBody)

        rightWallMesh.physicObject = rightWallBody

        this.roof = new THREE.Mesh(
            new THREE.PlaneGeometry(60, 60),
            new THREE.MeshStandardMaterial()
        )
        this.roof.rotation.x = Math.PI / 2
        this.roof.position.y = 30
        this.scene.add(this.roof)

        backWallMesh.name = 'backWall';
        frontWallMesh.name = 'frontWall';
        leftWallMesh.name = 'leftWall';
        rightWallMesh.name = 'rightWall';
    }
    
    loadTextures() {
        this.game.resources.on('ready', () => {
            
        })
    }

    renderPortal(){
        this.game.renderer.instance.clear();
        this.game.camera.instance.updateMatrixWorld(true);
        this.portalHandler.render(this.game.camera.instance, 0, this.virtualCamera, [this.rightPortal[0], this.leftPortal[0]],this.game.camera.instance.matrixWorld.clone(),this.game.camera.instance.projectionMatrix.clone());
    }
    
    update() {
        this.physics.step(1/60)

        this.contact = false

        this.physics.contacts.forEach((contact) => {
            let bodyA = contact.bi
            let bodyB = contact.bj
            if(((bodyA.class == 'player' && bodyB.class == 'portal') || (bodyB.class == 'player' && bodyA.class == 'portal')) && (this.rightPortal.length > 0 && this.leftPortal.length > 0)){
                this.contact = true
            }
        })

        if(!this.contact){
            this.physics.bodies.forEach((body) => {
                if(body.class !== 'portal'){
                    body.collisionResponse = true
                }
            })
        }

        else{
            this.leftPortal[0].physicObject.collisionResponse = false
            this.rightPortal[0].physicObject.collisionResponse = false
            if(this.leftPortal[0].physicObject.object.physicObject) this.leftPortal[0].physicObject.object.physicObject.collisionResponse = false
            if(this.rightPortal[0].physicObject.object.physicObject) this.rightPortal[0].physicObject.object.physicObject.collisionResponse = false
        }

        if(this.materialBlue){
            this.materialBlue.uniforms.iTime.value += 0.05;
        }
        if(this.materialOrange){
            this.materialOrange.uniforms.iTime.value += 0.05;
        }

        if (this.rightPortal.length > 0 && this.leftPortal.length > 0){
            this.rightPortal[0].pair = this.leftPortal[0]
            this.leftPortal[0].pair = this.rightPortal[0]
            this.game.camera.instance.layers.set(0)
            this.renderPortal()
            this.game.renderer.instance.clearDepth()
            this.game.camera.instance.layers.set(1)
            this.game.renderer.instance.render(this.scene, this.game.camera.instance)
        }
        else{
            this.game.camera.instance.layers.set(0)
            this.game.renderer.instance.render(this.scene, this.game.camera.instance)
            this.game.renderer.instance.clearDepth()
            this.game.camera.instance.layers.set(1)
            this.game.renderer.instance.render(this.scene, this.game.camera.instance)
        }

        this.managePortals()

        if (this.rightPortal.length > 0 && this.leftPortal.length > 0) {
            this.checkLeftPortalTeleport()
            this.checkRightPortalTeleport()
        } else {
            this.resetPortalColors()
        }
    }

    managePortals() {
        // Manage left portals
        this.leftPortal.forEach((portalData) => {
            this.scene.add(portalData)
        })

        if (this.leftPortal.length > 1) {
            const circleToRemove = this.leftPortal.shift()
            this.scene.remove(circleToRemove.box)
            this.scene.remove(circleToRemove.torus)
            this.physics.remove(circleToRemove.physicObject)
            this.scene.remove(circleToRemove)
        }

        // Manage right portals
        this.rightPortal.forEach((portalData) => {
            this.scene.add(portalData)
        })

        if (this.rightPortal.length > 1) {
            const circleToRemove = this.rightPortal.shift()
            this.scene.remove(circleToRemove.box)
            this.scene.remove(circleToRemove.torus)
            this.physics.remove(circleToRemove.physicObject)
            this.scene.remove(circleToRemove)
        }
    }

    teleport(sourcePortal, camera) {
        // Create Matrix4 instances for all required transformations
        const viewMat = new THREE.Matrix4().copy(camera.matrixWorld);
        const srcToCam = new THREE.Matrix4();
        const dstInverse = new THREE.Matrix4();
        const srcToDst = new THREE.Matrix4();
        const rotationYMatrix = new THREE.Matrix4().makeRotationY(Math.PI); // Example rotation, adjust as needed
        const result = new THREE.Matrix4();
    
        // Calculate srcToCam matrix
        srcToCam.multiplyMatrices(new THREE.Matrix4().copy(viewMat).invert(), sourcePortal.matrixWorld.clone());
        
        // Calculate dstInverse matrix
        dstInverse.copy(sourcePortal.pair.matrixWorld.clone()).invert();
        
        // Calculate srcToDst matrix
        srcToDst.identity().multiply(srcToCam).multiply(rotationYMatrix).multiply(dstInverse);
        
        // Calculate the final result matrix
        result.copy(srcToDst).invert();
    
        // Extract position and quaternion from the result matrix
        const position = new THREE.Vector3();
        const quaternion = new THREE.Quaternion();
        const scale = new THREE.Vector3();
        result.decompose(position, quaternion, scale);

        if(position.y < 9.98){
            position.y = sourcePortal.pair.position.y
            if(position.y < 9.98){
                position.y += 2.5
            }
        }

        camera.quaternion.copy(quaternion)
        this.game.controls.playerBody.position.set(position.x, position.y, position.z);
        this.game.controls.playerBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
    }

    checkLeftPortalTeleport() {

        const portalForward = new THREE.Vector3()
        this.rightPortal[0].getWorldDirection(portalForward)

        const travelerPosition = this.game.camera.instance.position.clone()
        const portalPosition = this.rightPortal[0].position.clone()
        const portalToTraveler = travelerPosition.sub(portalPosition)

        const dotProduct = portalForward.dot(portalToTraveler)

        if (dotProduct < 0) {
            this.teleport(this.rightPortal[0],this.game.camera.instance)
        }
    }

    checkRightPortalTeleport() {

        const portalForward = new THREE.Vector3()
        this.leftPortal[0].getWorldDirection(portalForward)

        const travelerPosition = this.game.camera.instance.position.clone()
        const portalPosition = this.leftPortal[0].position.clone()
        const portalToTraveler = travelerPosition.sub(portalPosition)

        const dotProduct = portalForward.dot(portalToTraveler)

        if (dotProduct < 0) {
            this.teleport(this.leftPortal[0],this.game.camera.instance)
        }
    }


    resetPortalColors() {
        if (this.leftPortal.length > 0) {
            this.leftPortal[0].material.color = new THREE.Color(0xff9a00)
            this.leftPortal[0].material.needsUpdate = true
        }

        if (this.rightPortal.length > 0) {
            this.rightPortal[0].material.color = new THREE.Color(0x00a2ff)
            this.rightPortal[0].material.needsUpdate = true
        }
    }
}